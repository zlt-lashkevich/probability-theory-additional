#set document(title: "Random Walk и числа Фибоначчи: метод Пойа")
#set page(paper: "a4", margin: 2cm)
#set text(lang: "ru", font: "New Computer Modern", size: 11pt)
#set par(justify: true, leading: 0.65em)
#show selector(<nonumber>): set heading(numbering: none)

#align(center)[
  #text(size: 16pt, weight: "bold")[
    Picture-Writing и производящие функции ]
]

#v(1em)

#align(center)[
  #text(size: 14pt, weight: "bold")[Часть I: Random Walk]
]

== Рассматриваем *симметричное случайное блуждание* на $ZZ$:

$
  S_n = x_1 + x_2 + ... + x_n, quad S_0 = 0
$

где $x_i$ — независимые одинаково распределённые случайные величины:

#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 4pt,
)[
  $ P(x_i = +1) = P(x_i = -1) = 1/2 $
]

== Символьное представление 

Введём символы для шагов:
- $arrow.t$ — шаг вверх ($x_i = +1$)
- $arrow.b$ — шаг вниз ($x_i = -1$)

*Траектория* длины $n$ — это слово из символов $arrow.t$ и $arrow.b$.

*Пример:* $arrow.t arrow.t arrow.b arrow.t arrow.b arrow.b$ означает путь $0 → 1 → 2 → 1 → 2 → 1 → 0$

= Множество траекторий как производящая функция

=== Определим операции:

#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 10pt,
  radius: 4pt,
)[
  *Сложение ($+$):* выбор альтернативы (дизъюнкция)
  
  $arrow.t + arrow.b$ означает "либо вверх, либо вниз"
  
  *Умножение ($dot$):* последовательное выполнение (конкатенация)
  
  $arrow.t dot arrow.b$ означает "сначала вверх, потом вниз"
]

Множество всех траекторий длины $n$:

$
  Q_n = {arrow.t, arrow.b}^n
$

Производящая функция:

$
  f(arrow.t, arrow.b) = (arrow.t + arrow.b) dot (arrow.t + arrow.b) dot ... dot (arrow.t + arrow.b) = (arrow.t + arrow.b)^n
$

При раскрытии скобок *каждый моном соответствует одной траектории*.

*Пример для $n = 2$:*
$
  (arrow.t + arrow.b)^2 = arrow.t arrow.t + arrow.t arrow.b + arrow.b arrow.t + arrow.b arrow.b
$

Четыре траектории: $\{↑↑, ↑↓, ↓↑, ↓↓\}$

=== Подсчёт количества

Для подсчёта числа траекторий подставляем $arrow.t = arrow.b = 1$:

$
  f(1, 1) = (1 + 1)^n = 2^n
$

#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 10pt,
  radius: 4pt,
)[
  *Принцип:* Подстановка единиц даёт количество элементов множества.
]

= Задача: Первое достижение уровня

Определим *момент первого достижения* уровня $+1$:

$
  tau = min{n >= 1 : S_n = 1}
$

с соглашением $tau = infinity$, если уровень никогда не достигается.

*Вопросы:*
1. $P(tau < infinity) = ?$ (вероятность когда-либо достичь)
2. $P(tau = n) = ?$ (вероятность достичь впервые на шаге $n$)

== Производящая функция для вероятности достижения

Обозначим:

$
  g(arrow.t, arrow.b) = P("траектория достигает уровня" +1)
$

#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 10pt,
  radius: 4pt,
)[
  *Ключевая идея Пойа:* Вместо перебора всех траекторий выведем *рекуррентное соотношение* для $g$.
]

== Выведем рекуррентное соотношение методом первого шага


*Случай 1: Первый шаг вверх* ($arrow.t$)

Мы сразу оказываемся на уровне $+1$ — цель достигнута!

Вклад: $arrow.t$

*Случай 2: Первый шаг вниз* ($arrow.b$)

Мы оказываемся на уровне $-1$. Чтобы достичь $+1$, нужно:
1. Сначала вернуться с $-1$ на $0$ (вероятность $g$, по симметрии)
2. Затем подняться с $0$ на $+1$ (снова вероятность $g$)

Вклад: $arrow.b dot g dot g = arrow.b g^2$



#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 12pt,
  radius: 4pt,
)[
  
  *Функциональное уравнение*
  
  $ g(arrow.t, arrow.b) = arrow.t + arrow.b dot g(arrow.t, arrow.b) dot g(arrow.t, arrow.b) $
  
  или короче:
  
  $ g = arrow.t + arrow.b g^2 $
]


#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 10pt,
  radius: 4pt,
)[
  = Коммутативная подстановка
  *Для получения числовых результатов* подставляем *одинаковые* значения:
  
  $ arrow.t = arrow.b = z $
  
  Это делает операцию умножения *коммутативной* и превращает символьную функцию в обычную функцию одной переменной.
]
#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 10pt,
  radius: 4pt,
)[

Обозначим $G(z) = g(z, z)$. Тогда:

$
  G(z) = z + z dot G^2(z)
$
]
*Получаем квадратное уравнение:*
  
  $ z G^2 - G + z = 0 $
$
  G = (1 plus.minus sqrt(1 - 4z^2))/(2z)
$

*Выбор корня:* При $z → 0$ должно быть $G(z) → 0$.

Проверяем:
$
  (1 - sqrt(1 - 4z^2))/(2z) →_(z→0) (1 - (1 - 2z^2 + ...))/(2z) → 0 quad checkmark
$

$
  (1 + sqrt(1 - 4z^2))/(2z) →_(z→0) infinity quad times
$

#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 4pt,
)[
  *Производящая функция:*
  
  $ G(z) = (1 - sqrt(1 - 4z^2))/(2z) $
]

== Разложение в ряд Тейлора


Используем известный биномиальный ряд:

$
  sqrt(1 - x) = sum_(k=0)^infinity binom(1/2, k) (-x)^k = 1 - x/2 - x^2/8 - x^3/16 - ...
$

где обобщённый биномиальный коэффициент:

$
  binom(1/2, k) = (1/2 dot (-1/2) dot (-3/2) dot ... dot (3/2 - k))/(k!)
$

Подставляем $x = 4z^2$:

$
  sqrt(1 - 4z^2) = sum_(k=0)^infinity binom(1/2, k) (-4z^2)^k
$

$
  1 - sqrt(1 - 4z^2) = -sum_(k=1)^infinity binom(1/2, k) (-4)^k z^(2k)
$

== Связь с числами Каталана

После упрощений получаем:

$
  G(z) = sum_(n=0)^infinity C_n z^(2n+1)
$

где $C_n$ — *$n$-е число Каталана*:

$
  C_n = 1/(n+1) binom(2n, n)
$

#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 10pt,
  radius: 4pt,
)[
  *Разложение:*
  
  $ G(z) = z + z^3 + 2z^5 + 5z^7 + 14z^9 + 42z^(11) + ... $
  
  Коэффициенты: $1, 1, 2, 5, 14, 42, ...$ — числа Каталана
]

= Извлечение вероятностей

== Метод 1: Коэффициенты ряда

Коэффициент при $z^n$ в $G(z)$ связан с вероятностью $P(tau = n)$.

При подстановке *вероятностей* $arrow.t = arrow.b = 1/2$:

$
  P(tau = 2k+1) = C_k dot (1/2)^(2k+1) = C_k / 2^(2k+1)
$


== Метод 2: Дифференцирование

Для нахождения $[z^n] G(z)$ используем:

$
  [z^n] G(z) = 1/(n!) (d^n G)/(d z^n) |_(z=0)
$

#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 10pt,
  radius: 4pt,
)[
  *Алгоритм:*
  
  1. Вычислить $n$-ю производную $G^((n))(z)$
  2. Подставить $z = 0$
  3. Поделить на $n!$
  
  Результат: коэффициент при $z^n$, связанный с $P(tau = n)$
]

= 1) Вероятность достижения за конечное время

Подставляем $z = 1/2$:

$
  G(1/2) = (1 - sqrt(1 - 4 dot 1/4))/(2 dot 1/2) = (1 - 0)/1 = 1
$

#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 10pt,
  radius: 4pt,
)[
  *Результат:*
  
  $ P(tau < infinity) = 1 $
  
  Симметричное случайное блуждание *почти наверное* достигает любого уровня!
]


= 2) Вычисление $P(tau = n = 33)$

#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 10pt,
  radius: 4pt,
)[
  == Ключевое наблюдение
  *Чётность:* Достичь уровня $+1$ можно только за *нечётное* число шагов!
  
  Причина: Начинаем с $S_0 = 0$ (чётное). Каждый шаг меняет чётность позиции. Уровень $+1$ — нечётный, поэтому нужно нечётное число шагов.
]

== Производящая функция

Из разложения:

$
  G(z) = (1 - sqrt(1 - 4z^2))/(2z)
$

Используем биномиальный ряд для $sqrt(1-x)$:

$
  sqrt(1 - x) = sum_(k=0)^infinity binom(1/2, k) (-x)^k
$

== Обобщённый биномиальный коэффициент

$
  binom(1/2, k) = ((1/2)(1/2 - 1)(1/2 - 2) dots.c (1/2 - k + 1))/(k!) quad
  = ((1/2)(-1/2)(-3/2) dots.c ((3-2k)/2))/(k!)
$

Для $k = 17$:

$
  binom(1/2, 17) = ((1/2)(-1/2)(-3/2) dots.c (-31/2))/(17!)
$

=== Упрощение числителя

Числитель содержит 17 множителей:

$
  (1/2) dot (-1/2) dot (-3/2) dot dots.c dot (-31/2) = 1/(2^17) dot 1 dot (-1) dot (-3) dot dots.c dot (-31)
$

Отрицательных членов 16 (от $-1$ до $-31$):

$
  = ((-1)^16)/(2^17) dot (1 dot 1 dot 3 dot 5 dot dots.c dot 31) = (31!!)/(2^17)
$

== Итоговая формула

#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 12pt,
  radius: 4pt,
)[
  $ binom(1/2, 17) = (31!!)/(2^17 dot 17!) $
]
== Формула для чисел Каталана
#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 4pt,
)[

Для нечётного $n = 2k + 1$:

  $ P(tau = 2k+1) = C_k dot (1/2)^(2k+1) = C_k / 2^(2k+1) $


Для чётного $n$: $P(tau = n) = 0$
]

Известно, что:

$
  C_n = (2^n (2n-1)!!)/((n+1)!)quad  -> quad 
  C_16 = (2^16 dot 31!!)/(17!)
$
#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 12pt,
  radius: 4pt,
)[
  *Обе формулы эквивалентны:*
  $
  P(tau = 33) = C_16 / 2^33 = (2^16 dot 31!!)/(17! dot 2^33) = (31!!)/(2^17 dot 17!)
$

  $ P(tau = 33) = binom(1/2, 17) = (31!!)/(2^17 dot 17!) = C_16/2^33 $
]

#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 15pt,
  radius: 4pt,
)[
== Итоговая вероятность

$
  P(tau = 33) = C_(16) / 2^(33) = 35357670 / 8589934592 approx 0.004116 approx 0.41%
$
]

= Метод 2: дифференцирование


Коэффициент при $z^n$ в производящей функции:

$
  [z^n] G(z) = 1/(n!) (d^n G)/(d z^n)|_(z=0)
$

== Применение к $G(z)$

Для $G(z) = (1 - sqrt(1-4z^2))/(2z)$ нужно вычислить 33-ю производную в нуле.

Используем разложение:

$
  sqrt(1 - 4z^2) = sum_(k=0)^infinity binom(1/2, k) (-4z^2)^k
$

$
  = 1 - 2z^2 - 2z^4 - 4z^6 - 10z^8 - ...
$

где коэффициенты связаны с числами Каталана.

После дифференцирования и подстановки получаем тот же результат:

$
  [z^(33)] G(z) = C_(16)
$

При подстановке вероятностей $z = 1/2$:

$
  P(tau = 33) = C_(16) dot (1/2)^(33)
$

= Общая формула для произвольного нечётного $n = 2k + 1$

#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 12pt,
  radius: 4pt,
)[
  $ P(tau = 2k+1) = binom(1/2, k+1) = ((2k-1)!!)/(2^(k+1) dot (k+1)!) = C_k / 2^(2k+1) $
]


= Красота формулы

#align(center)[
  #box(
    width: 90%,
    fill: rgb("#f0f8ff"),
    inset: 15pt,
    radius: 4pt,
  )[
    
    Вероятность первого достижения уровня $+1$ на шаге $n = 2k+1$ в случайном блуждании выражается через *обобщённый биномиальный коэффициент* с полуцелым верхним индексом:
    
    $ P(tau = 2k+1) = binom(1/2, k+1) $
    
    Это прямое следствие разложения $sqrt(1-x)$ в биномиальный ряд!
  ]
]

#pagebreak()

#align(center)[
  #text(size: 14pt, weight: "bold")[Часть II: Числа Фибоначчи]
]

= Модель кроликов


#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 4pt,
)[
  *Типы кроликов:*
  
  - $S$ — *Семейные* (взрослые пары, способные к размножению)
  - $M$ — *Молодые* (новорождённые пары)
  
  *Правила эволюции* (за один месяц):
  
  - $S → S + M$ (семейная пара производит молодую и остаётся)
  - $M → S$ (молодая пара взрослеет)
]

*Начальное условие:* В месяце 0 имеем одну молодую пару: $M$



== Эволюция системы

#table(
  columns: 6,
  stroke: 0.5pt,
  inset: 6pt,
  align: center,
  fill: (col, row) => if row == 0 { rgb("#e8f4f8") },
  
  [*Месяц $n$*], [*$S$ (семейных)*], [*$M$ (молодых)*], [*Всего $F_n$*], [*Состояние*], [*Переход*],
  
  [0], [0], [1], [1], [$M$], [—],
  [1], [1], [0], [1], [$S$], [$M→S$],
  [2], [1], [1], [2], [$S+M$], [$S→S+M$],
  [3], [2], [1], [3], [$2S+M$], [$S→S+M, M→S$],
  [4], [3], [2], [5], [$3S+2M$], [...],
  [5], [5], [3], [8], [$5S+3M$], [...],
  [6], [8], [5], [13], [$8S+5M$], [...],
)

*Наблюдение:* $F_n = s_n + m_n$ образует последовательность *Фибоначчи*!

== Производящая функция для кроликов

Состояние в месяце $n$:

$
  G_n (S, M) = s_n dot S + m_n dot M
$

где $s_n$ — количество семейных, $m_n$ — количество молодых пар.

Из правил эволюции:

$
  s_(n+1) &= s_n + m_n quad &"(семейные остаются + молодые взрослеют)" \
  m_(n+1) &= s_n quad &"(семейные рожают)"
$


Обозначим $F_n = s_n + m_n$ — общее количество пар.

$
  F_(n+1) &= s_(n+1) + m_(n+1) = (s_n + m_n) + s_n = F_n + s_n
$

Но $s_n = m_(n+1) = s_(n-1) + m_(n-1) = F_(n-1)$ (из предыдущего шага).

#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 10pt,
  radius: 4pt,
)[
  *Рекуррентная формула Фибоначчи:*
  
  $ F_(n+1) = F_n + F_(n-1), quad F_0 = 1, space F_1 = 1 $
]

= Рекуррентное соотношение для производящей функции

== Функциональное уравнение 

Рассмотрим производящую функцию состояния $F(S, M)$:

$
  F(S, M) = S + M
$

означает: текущее состояние — это либо семейная, либо молодая пара.

*Правило перехода за один шаг:*
- $S → S + M$ (семейная производит молодую)
- $M → S$ (молодая взрослеет)

*Производящая функция "эволюции":*

После одного шага:
$
  T(S, M) = S dot (S + M) + M dot S = S^2 + S M + M S = S^2 + 2 S M
$

Но это для одного шага. Для бесконечной эволюции нужен другой подход.

== Производящая функция для последовательности

Определим:

$
  G(z) = sum_(n=0)^infinity F_n z^n
$

Из рекуррентности $F_(n+1) = F_n + F_(n-1)$:

$
  sum_(n=1)^infinity F_(n+1) z^(n+1) = sum_(n=1)^infinity F_n z^(n+1) + sum_(n=1)^infinity F_(n-1) z^(n+1)
$

$
  G(z) - F_0 - F_1 z = z(G(z) - F_0) + z^2 G(z)
$

С $F_0 = F_1 = 1$:

$
  G(z) - 1 - z = z G(z) - z + z^2 G(z)
$

$
  G(z)(1 - z - z^2) = 1
$

#box(
  width: 100%,
  fill: rgb("#e8f4f8"),
  inset: 12pt,
  radius: 4pt,
)[
  *Производящая функция Фибоначчи:*
  
  $ G(z) = 1/(1 - z - z^2) $
]

== Нахождение корней знаменателя

$
  1 - z - z^2 = 0 quad arrow.r.double quad z^2 + z - 1 = 0
$

$
  z = (-1 plus.minus sqrt(5))/2
$

Обозначим:
$
  phi = (1 + sqrt(5))/2 approx 1.618 quad "(золотое сечение)"
$

$
  hat(phi) = (1 - sqrt(5))/2 approx -0.618
$

Тогда корни: $z_1 = 1/phi$, $z_2 = 1/hat(phi)$

== Разложение на простейшие дроби

$
  1 - z - z^2 = -(z - 1/phi)(z - 1/hat(phi))
$

Используя $phi dot hat(phi) = -1$:

$
  G(z) = 1/(1 - z - z^2) = A/(1 - phi z) + B/(1 - hat(phi) z)
$

Находим коэффициенты:

$
  A = phi/sqrt(5), quad B = -hat(phi)/sqrt(5)
$

== Разложение в геометрический ряд

$
  1/(1 - phi z) = sum_(n=0)^infinity (phi z)^n = sum_(n=0)^infinity phi^n z^n
$

$
  1/(1 - hat(phi) z) = sum_(n=0)^infinity hat(phi)^n z^n
$

Собираем:

$
  G(z) = 1/sqrt(5) sum_(n=0)^infinity (phi^(n+1) - hat(phi)^(n+1)) z^n
$

#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 12pt,
  radius: 4pt,
)[
  *Формула Бине (коэффициент при $z^n$):*
  
  $ F_n = (phi^n - hat(phi)^n)/sqrt(5) $
  
  где $phi = (1 + sqrt(5))/2$, $hat(phi) = (1 - sqrt(5))/2$
]


#box(
  width: 100%,
  fill: rgb("#fff4e6"),
  inset: 10pt,
  radius: 4pt,
)[
== Нахождение $F_(2025)$, примененив формулу Бине

$
  F_(2025) = (phi^(2025) - hat(phi)^(2025))/sqrt(5)
$


Так как $|hat(phi)| = (sqrt(5) - 1)/2 approx 0.618 < 1$:

$
  |hat(phi)^(2025)| approx 0.618^(2025) approx 0
$
  
  *Точная формула:*
  
  $ F_(2025) = "round"(phi^(2025)/sqrt(5)) $
]

== Метод 2:  дифференцирования (альтернатива)

$n$-й коэффициент можно найти через производную:

$
  F_n = [z^n] G(z) = 1/(n!) (d^n G)/(d z^n)|_(z=0)
$

Для $G(z) = 1/(1-z-z^2)$ это требует $n$ дифференцирований.

*Практически* для $n = 2025$ используют:
- Рекуррентную формулу $F_(n+1) = F_n + F_(n-1)$ (итеративно)
- Матричное возведение в степень (за $O(log n)$)

== Численная оценка

$
  log_(10) F_(2025) approx 2025 dot log_(10) phi - 1/2 log_(10) 5
$

$
  log_(10) phi approx 0.20898
$

$
  log_(10) F_(2025) approx 2025 times 0.20898 - 0.35 approx 422.83
$

#box(
  width: 100%,
  fill: rgb("#e8f8e8"),
  inset: 12pt,
  radius: 4pt,
)[
  *Результат:*
  
  $ F_(2025) approx 6.76 times 10^(422) $
  
  Это число с *423 десятичными цифрами*!
]

#pagebreak()

= Общая схема метода

#align(center)[
#box(
  width: 95%,
  fill: rgb("#f0f8ff"),
  inset: 15pt,
  radius: 4pt,
)[
#text(size: 10pt)[

*Шаг 1: Символьное представление*

Кодируем объекты/траектории символами ($arrow.t$, $arrow.b$ или $S$, $M$)

Множество объектов = производящая функция символов

#v(0.3em)
$arrow.b$
#v(0.3em)

*Шаг 2: Рекуррентное соотношение*

Анализ "первого шага" или правил эволюции

$g = arrow.t + arrow.b g^2$ или $F(S,M) = ...$

#v(0.3em)
$arrow.b$
#v(0.3em)

*Шаг 3: Коммутативная подстановка*

$arrow.t = arrow.b = z$ (или переход к одной переменной)

Получаем алгебраическое уравнение

#v(0.3em)
$arrow.b$
#v(0.3em)

*Шаг 4: Решение уравнения*

Находим $G(z)$ в замкнутой форме

#v(0.3em)
$arrow.b$
#v(0.3em)

*Шаг 5: Разложение в ряд Тейлора*

Используем известные ряды (геометрический, биномиальный, ...)

$G(z) = sum a_n z^n$

#v(0.3em)
$arrow.b$
#v(0.3em)

*Шаг 6: Извлечение коэффициентов*

Метод 1: Непосредственно из ряда $a_n = [z^n] G(z)$

Метод 2: Дифференцирование $a_n = 1/(n!) G^((n))(0)$

#v(0.3em)
$arrow.b$
#v(0.3em)

*Шаг 7: Подстановка вероятностей*

$z = 1/2$ для вероятностей, $z = 1$ для подсчёта, и т.д.

]
]
]

